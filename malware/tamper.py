#!/usr/bin/env python3
"""
Simulated multi-victim worm (controller-driven).
Adds manifest + agent logging + integration with initial access simulation.
This is a SAFE educational malware lab.
"""

import os, shutil, time, random, sys, hashlib
from datetime import datetime
from pathlib import Path


# --------------------------------------------------------------------------
# Read victims dynamically
# --------------------------------------------------------------------------

ENV_DIRS = os.environ.get("VICTIM_DIRS", "").strip()
COMMAND_DIR = Path(os.environ.get("COMMAND_DIR", "/commands")).resolve()

if ENV_DIRS:
    TARGET_DIRS = [Path(p).resolve() for p in ENV_DIRS.split(",")]
else:
    TARGET_DIRS = [Path("/data/assignments").resolve()]

CMD_FILE = COMMAND_DIR / "command.txt"
STATUS_FILE = COMMAND_DIR / "status.txt"


# --------------------------------------------------------------------------
# Initial access token directory (SAFE simulation)
# --------------------------------------------------------------------------

TOKEN_DIR = Path("/home/seed/Documents/CMPT280/Final_Project/collected")
TOKEN_FILES = [
    "simulated_terminal_tokens.txt",
    "simulated_web_tokens.txt",
]


def load_simulated_tokens():
    """Loads fake 'victim access' tokens. SAFE simulation only."""
    tokens = []
    for fname in TOKEN_FILES:
        fp = TOKEN_DIR / fname
        if fp.exists():
            for line in fp.read_text().splitlines():
                line = line.strip()
                if not line:
                    continue
                tokens.append(line)
    return tokens


def pick_target_dirs_from_tokens(tokens):
    """
    Use a hash of each token to select a subset of TARGET_DIRS.
    If there are no tokens, fall back to all TARGET_DIRS.
    """
    if not TARGET_DIRS:
        return []

    if not tokens:
        # No initial access = no targeting info -> simulate broadcast attack
        return TARGET_DIRS

    selected = set()

    for token in tokens:
        # Very generic: hash entire line. This works even if format changes.
        h = hashlib.sha256(token.encode("utf-8")).hexdigest()
        idx = int(h, 16) % len(TARGET_DIRS)
        selected.add(TARGET_DIRS[idx])

    return sorted(selected, key=lambda p: str(p))


# --------------------------------------------------------------------------
# Constants
# --------------------------------------------------------------------------

EXTS = {".py", ".txt", ".md", ".c", ".java"}

FAKE_FILE_NAMES = [
    "results.tmp",
    "cache.bak",
    "system32.dll.fake",
    "report_copy.docx.fake",
    "submission_v2.py.bak",
]

FAKE_FILE_CONTENT = "AUTO-GEN FILE\nNot harmful.\n"
REPLICA_NAME = "replica_marker.txt"
MANIFEST = "manifest.log"


# --------------------------------------------------------------------------
# Safety check
# --------------------------------------------------------------------------

for td in TARGET_DIRS:
    if "victim" not in str(td).lower() and "assignments" not in str(td).lower():
        raise SystemExit(f"[SAFE] REFUSED: {td}")

COMMAND_DIR.mkdir(parents=True, exist_ok=True)

print("\n[WORM] Targets (all possible victims):")
for d in TARGET_DIRS:
    print(" ->", d)
print()


# --------------------------------------------------------------------------
# Manifest functions
# --------------------------------------------------------------------------

def file_hash(path: Path):
    try:
        return hashlib.sha256(path.read_bytes()).hexdigest()
    except Exception:
        return "unreadable"


def manifest(td: Path, filepath: Path, action: str):
    mf = td / MANIFEST
    ts = datetime.now().isoformat()
    h = file_hash(filepath)
    entry = f"{ts} | {action} | {filepath.name} | hash={h}\n"
    with open(mf, "a") as f:
        f.write(entry)


# --------------------------------------------------------------------------
# Logging utilities
# --------------------------------------------------------------------------

def write_status(text):
    ts = datetime.now().isoformat()
    with open(STATUS_FILE, "w") as f:
        f.write(f"{ts} | {text}\n")


def log(msg):
    ts = datetime.now().isoformat()
    print(f"{ts} | {msg}")
    # Keep logging to ALL target dirs so instructor can see global activity
    for td in TARGET_DIRS:
        with open(td / ".simworm_log.txt", "a") as f:
            f.write(f"{ts} | {msg}\n")


# --------------------------------------------------------------------------
# Core operations
# --------------------------------------------------------------------------

def find_target_files(base):
    for root, _, files in os.walk(base):
        if ".trash_demo" in root:
            continue
        for f in files:
            p = Path(root) / f
            if p.suffix.lower() in EXTS:
                yield p


def backup(p):
    trash_dir = p.parent / ".trash_demo_backup"
    trash_dir.mkdir(exist_ok=True)
    dest = trash_dir / f"{datetime.now():%Y%m%d_%H%M%S}_{p.name}"
    shutil.copy2(p, dest)


def replicate(dirs=None):
    """Create replica marker files across selected victim dirs."""
    dirs = dirs or TARGET_DIRS
    for td in dirs:
        for root, _, _ in os.walk(td):
            dest = Path(root) / REPLICA_NAME
            if not dest.exists():
                dest.write_text("SAFE WORM REPLICA\n")
                log(f"[spread] created {dest}")
                manifest(td, dest, "replicate")


def fake_files(dirs=None):
    """Drop harmless fake files in selected victim dirs."""
    dirs = dirs or TARGET_DIRS
    for td in dirs:
        for name in FAKE_FILE_NAMES:
            fp = td / name
            fp.write_text(FAKE_FILE_CONTENT)
            log(f"[fake] created {fp}")
            manifest(td, fp, "fake-created")


def tamper(p):
    td = p.parent
    manifest(td, p, "tamper")
    backup(p)
    with open(p, "a", encoding="utf-8", errors="ignore") as f:
        f.write(f"# TAMPER: {datetime.now()}\n")
    log(f"[tamper] modified {p}")


def wait_for_attack():
    log("[controller] waiting for ATTACK...")
    write_status("IDLE")
    while True:
        if CMD_FILE.exists():
            cmd = CMD_FILE.read_text().strip().upper()
            if cmd == "ATTACK":
                log("[controller] ATTACK received")
                write_status("ATTACK")
                return
        time.sleep(2)


# --------------------------------------------------------------------------
# Main execution
# --------------------------------------------------------------------------

def main_loop():
    # LOAD SIMULATED INITIAL ACCESS TOKENS (SAFE)
    tokens = load_simulated_tokens()
    log(f"[initial-access] Loaded {len(tokens)} simulated access tokens")
    for t in tokens:
        log(f"[initial-access] token={t}")

    # USE TOKENS TO PICK WHICH VICTIM DIRECTORIES ARE ACTIVE
    active_dirs = pick_target_dirs_from_tokens(tokens)

    log(f"[targeting] Using {len(active_dirs)} active victim directories (out of {len(TARGET_DIRS)})")
    for d in active_dirs:
        log(f"[targeting] active -> {d}")

    wait_for_attack()

    for cycle in range(1, 4):
        write_status(f"CYCLE {cycle}")
        replicate(dirs=active_dirs)
        fake_files(dirs=active_dirs)

        for td in active_dirs:
            for p in find_target_files(td):
                if random.random() < 0.6:
                    tamper(p)
                else:
                    backup(p)

        time.sleep(3)

    write_status("DONE")
    log("DONE")


# --------------------------------------------------------------------------
# Entry
# --------------------------------------------------------------------------

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--restore":
        print("Use restore.py instead.")
        sys.exit()
    main_loop()
